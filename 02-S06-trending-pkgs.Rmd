## compare download counts with the number of updates for all 100 trending packages

Next, let's look at the relationship between the number of updates and the number of downloads.
In this part, our analysis object is still trending packages.

```{block, type="discovery", echo = TRUE}
**Finding 1**: The download count tends to rise with the number of updates.This is because as we have known before, when a package is updated, there will be a significant increase in the number of downloads. That is to say, when a package is updated, not only old users will download the latest version, but also it is easier to attract new users at this time, for the increase of downloads in a short time may bring it into the trending list.
```

```{r function-updates-downloads}

# function used to get total updates and total downloads for a vector of packages
get_updates_downloads <- function(packages){
  
update_count <- function(packages){

  
  # get all the update dates and compute the number of updates of each package  
pkg_trending_updates <- get_arcvupdate_date(packages) %>%
  dplyr::group_by(package) %>%
  dplyr::count(package) %>%
  rename(`number of updates` = n)

}

update_counts <- update_count(packages) 

# get total downloads for each package 
total_downloads <- get_total_downloads(update_counts$package)

# join data
update_counts <- update_counts %>%
  as.data.frame() %>%
  left_join(total_downloads,by = "package")

return(update_counts)

}


```

Figure \@ref(fig:trend-updates) shows that the number of downloads increases with the update times. And most packages are updated between 1 and 6 times.

```{r  trend-updates, fig.align = 'center', fig.cap=" The number of downloads increases with the increase of update times."}
pkg_trending_updates <- get_updates_downloads(pkg_trending$package) %>%
  mutate(score = as.numeric(count)) %>%
  mutate(updates = as.numeric(`number of updates`)) %>%
  arrange(desc(count))

pkg_trending_updates %>%
  ggplot(aes(x = `number of updates`, y = count)) +
  geom_point() +
  geom_smooth(se = F) +
  scale_x_log10() +
    labs( x = 'The number of updates',
          y = 'Total download count',
    title = "Update counts against download counts",
    subtitle = "for 100 trending packages") +
  theme_minimal()  +
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank()) +
  theme(
  axis.text=element_text(size=10),
  axis.title=element_text(size=12,face="bold"),
  plot.title = element_text(h = 0.5),
  plot.subtitle = element_text(h = 0.5))
```

```{block, type="discovery", echo = TRUE}
**Finding 2**: Over half of the trending packages don't tend to update as frequently as expected.
```

Also checking Table \@ref(tab:pct-lowupdates), we can know that the percentage of trending packages whose updates are less than average is 71 %, which means much more than half of the 100 trending packages do not tend to update very frequently. 


```{r  function-lowupdates}
# function used to compute packages lying in the low-updated range

compute_pct_lowupdated <- function(packages){
  
avg_updates <- mean(as.numeric(get_updates_downloads(packages)$`number of updates`))

pkg_trending_total <- length(packages)

pct_trending_updates <- get_updates_downloads(packages) %>%
  mutate(`number of updates` = as.numeric(`number of updates`))  %>%
  dplyr::filter(`number of updates` < avg_updates) %>%
  dplyr::summarise(`number of packages with low updates` = length(package)) %>%
  mutate(`percentage of packages with low updates` = (`number of packages with low updates`/pkg_trending_total)*100)

pct_trending_updates%>%
  kable(caption = "Percentage of trending packages whose updates are less than average") %>%
  kable_styling(bootstrap_options = c("hover", "striped"))

return(pct_trending_updates)

}

```

```{r pct-lowupdates}
# get the percentage of packages whose update counts is under the average
compute_pct_lowupdated(pkg_trending$package) 
  
```


```{block, type="discovery", echo = TRUE}
**Finding 3**: Most trending packages keep updates with the time to keep its activity.
```

It can be seen from Figure \@ref(fig:latestpublish) that most top 15 trending packages' latest publish date is after 2021, which indicates that popular packages tend to update by time to keep its activity. And this can also be explained from another aspect, that is, a trending package refers to a package with a high download volume in a short period of recent time. We know that when a package is updated, its downloads will increase, so the latest update dates of trending packages are almost all the recent dates.

```{r function-latestupdate}
# function used to get the total downloads of a period of time and the latest release date
downloads_latest_release <- function(packages) {

# function used to get the latest release date from CRAN
latest_updates <- function(packages){
  
  latest_updates <- get_arcvupdate_date(packages) %>%
  group_by(package) %>%
  arrange(update, .by_group = TRUE) %>% #arrange within group
  top_n(1, update) # to get the latest release date, top_n() is used to select the highest value of a column within each group
  
}

latest_updates <- latest_updates(packages)

packages_vector <- latest_updates$package


# function used to get the total downloads of a period of time (date1 to date2) for several packages at the same time
get_total_downloads <- function(packages_vector){
  
total_downloads <- map(packages_vector, function(pkg){
  
  pkg <- cran_downloads(package = paste0(pkg), from = date1, to = date2) %>%
  summarise(package = package, count = sum(count)) %>%
  head(1)
  
})

 names(total_downloads) <- packages_vector

downloads <- unlist(total_downloads) %>% 
  enframe("package", "count") %>% 
  mutate(count = suppressWarnings(as.numeric(count)),
         # need to get rid of the numbers appended to pkg names
         package = str_extract(package, paste0(packages_vector, collapse="|")))%>%
         na.omit()
}

downloads <- get_total_downloads(packages_vector)
  
downloads_release_latest <- downloads %>%
  as.data.frame() %>%
  left_join(latest_updates,by = "package")

return(downloads_release_latest)
}
```


```{r  latestpublish,fig.align = 'center', fig.cap=" Most top 15 trending packages' latest publish date is after 2021."}

# before use the function 'downloads_latest_release()', please set the time range
date1 <- lh_dt_start
date2 <- lh_dt_end

pkg_trending1 <- pkg_trending %>%
  filter(!(package == "distro")) %>%
  filter(!(package == "decor")) %>%
  filter(!(package == "SeuratObject")) %>%
  filter(!(package == "bslib"))

pkg_trending_latest_publish <- unique(downloads_latest_release(pkg_trending1$package))

pkg_trending_latest_publish %>%
  ggplot(aes(update)) +
  geom_density() +
  labs( 
        x = 'Latest publish date',
    title = "Distribution of latest publish date",
    subtitle = "for trending packages") +
  theme_minimal()  +
  theme(panel.grid.major = element_blank()) +
  theme(
  axis.text=element_text(size=10),
  axis.title=element_text(size=12,face="bold"),
  plot.title = element_text(h = 0.5),
  plot.subtitle = element_text(h = 0.5))
```


```{block, type="discovery", echo = TRUE}
**Finding 4**: Most of the trending packages are likely to update at a longer time interval.
```

Figure \@ref(fig:updates-perday) shows that with the increase of update interval, the number of downloads first increases and then decreases slightly. And most of the time intervals are between 45 and 450 days, which shows that their update frequency is not very high.

```{r updates-perday}

pkg_trending_earliest_publish <- unique(downloads_earliest_release(pkg_trending_latest_publish$package))

pkg_trending_daily_update <- left_join(pkg_trending_earliest_publish,pkg_trending_latest_publish,by = "package") %>%
  select(-count.y) %>%
  rename(count = count.x) %>%
  mutate(release_days = as.numeric(update.y - update.x)) 

pkg_trending_daily_update$release_days <- as.character(pkg_trending_daily_update$release_days)
pkg_trending_daily_update$release_days[pkg_trending_daily_update$release_days == "0"] <- "1"

pkg_trending_daily_update$release_days <- as.numeric(pkg_trending_daily_update$release_days)

pkg_trending_daily_update <- pkg_trending_daily_update %>%
left_join(get_updates_downloads(pkg_trending_daily_update$package))

pkg_trending_daily_update %>%
  mutate(days_peruodate = release_days/`number of updates`) %>%
  ggplot(aes(x = days_peruodate, y = count)) +
  geom_point(aes(colour = `number of updates`)) +
  geom_smooth(se = F) +
  labs( y = 'Total download counts',
          x = 'Days per update',
    title = "Daily update counts against the download counts",
    subtitle = "for trending packages") +
  scale_color_continuous(trans = 'log10') +
  scale_x_log10() +
  scale_y_sqrt() +
  theme_minimal()  +
  theme(panel.grid.major = element_blank()) +
  theme(
  axis.text=element_text(size=10),
  axis.title=element_text(size=12,face="bold"),
  plot.title = element_text(h = 0.5),
  plot.subtitle = element_text(h = 0.5))
```


In conclusion, it's not that the more updates the package has, the popular it will be. In the trending package, most of the packages whose updates are lower than the average occupy the majority. Therefore, we can also know that the total number of updates is not very important for the trending package. The important thing is to keep it updated with the time.

